try:
    app
except NameError:
    from fastapi import FastAPI
    app = FastAPI(docs_url='/docs', openapi_url='/openapi.json')
# --- BasicAuth middleware ---
import os, base64
from fastapi import Request, HTTPException
_USER=os.getenv('TASK_API_BASIC_USER','lsa')
_PASS=os.getenv('TASK_API_BASIC_PASS','changeme')
_OPEN=('/health','/tasks/ping')
@app.middleware('http')
async def _basic_guard(request: Request, call_next):
    p=str(request.url.path)
    if any(p.startswith(x) for x in _OPEN):
        return await call_next(request)
    auth=request.headers.get('Authorization','')
    need='Basic '+base64.b64encode(f'{_USER}:{_PASS}'.encode()).decode()
    if auth!=need:
        raise HTTPException(status_code=401, detail='Unauthorized')
    return await call_next(request)



# BASIC_AUTH_MW_START
import os, base64, binascii
from starlette.responses import Response
_ALLOW_OPEN = ("/health", "/openapi.json", "/docs", "/redoc")
_USER=os.getenv("TASK_API_BASIC_USER","")
_PASS=os.getenv("TASK_API_BASIC_PASS","")
def _need_auth(path): return not any(path.startswith(p) for p in _ALLOW_OPEN)
def _unauth():
    return Response(status_code=401, headers={"WWW-Authenticate":"Basic realm=\"Local Task API\""})
@app.middleware("http")
async def _basic_auth_mw(request, call_next):
    if not _need_auth(request.url.path): return await call_next(request)
    h = request.headers.get("Authorization","")
    if h.lower().startswith("basic "):
        try:
            u,p=base64.b64decode(h.split(" ",1)[1]).decode().split(":",1)
            if u==_USER and p==_PASS: return await call_next(request)
        except Exception: pass
    return _unauth()
# BASIC_AUTH_MW_END

import time
import logging
from fastapi.responses import FileResponse
import re
import os
from fastapi import HTTPException, Request, Query
#!/usr/bin/env python3
from collections import defaultdict, deque
import os, hmac, json, datetime as dt
from pathlib import Path
from fastapi import FastAPI, Request, Query
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.responses import Response

# ==== CONFIG ====
_BUSER = os.getenv("TASK_API_BASIC_USER", "lsa")
_BPASS = os.getenv("TASK_API_BASIC_PASS", "changeme")

# ==== BASIC AUTH ====
def _parse_bearer(h: str|None):
    if not h: return None
    h=h.strip()
    if h.lower().startswith('bearer '): return h.split(' ',1)[1]
    if h.lower().startswith('token '):  return h.split(' ',1)[1]
    return None


def _parse_basic(auth):
    if not auth or not auth.lower().startswith("basic "):
        return None, None
    import base64
    try:
        u, p = base64.b64decode(auth.split()[1]).decode().split(":", 1)
        return u, p
    except Exception:
        return None, None

def _needs_auth(path: str) -> bool:
    # allow health/ping + metrics + reports/list without auth (dev)
    if path.startswith("/health") or path.startswith("/tasks/ping") or path.startswith("/metrics") or path.startswith("/reports/list"):
        return False

def _sec_log(msg): print(msg, flush=True)

_RL_BUCKETS = defaultdict(lambda: deque())
_RATE_LIMIT = int(os.getenv('TASK_API_RATE_PER_MIN','10'))

class _BasicAuthMW(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        path = request.url.path
        # ip_allow_guard
        ip = (request.client.host if request.client else '?')
        allow = globals().get('_ALLOW_IPS', set())
        if allow and ip not in allow:
            return Response('Forbidden', status_code=403)
        # sec404 docs/openapi
        if path == '/openapi.json' or path.startswith('/docs'):
            return Response('Not Found', status_code=404)
        ## removed hard-protect guard (replaced by sec404)
        if path == '/openapi.json' or path.startswith('/docs'):
            authh = request.headers.get('authorization')
            u,p = _parse_basic(authh)
            _t  = _parse_bearer(authh) if ' _parse_bearer' in globals() or '_parse_bearer' in s else None
            ok = (u is not None and hmac.compare_digest(u, _BUSER or '') and hmac.compare_digest(p or '', _BPASS or '')) or (_t and hmac.compare_digest(_t, (os.getenv('TASK_API_TOKEN','') or '')))
            if not ok:
                return Response('Unauthorized', status_code=401, headers={'WWW-Authenticate':'Basic realm="task-api"'})
        if not _needs_auth(path):
            return await call_next(request)
        authh = request.headers.get('authorization')
        u, p = _parse_basic(authh)
        _t = _parse_bearer(authh)
        # rate-limit
        now=time.time(); ip=(request.client.host if request.client else '?')
        q=_RL_BUCKETS[ip];
        while q and now-q[0]>60: q.popleft()
        q.append(now)
        if len(q) > _RATE_LIMIT:
            _sec_log(f'RLIMIT path={path} ip={ip} n={len(q)}')
            return Response('Too Many Requests', status_code=429)
        ok = (
            (u is not None and hmac.compare_digest(u, _BUSER or '') and hmac.compare_digest(p or '', _BPASS or ''))
            or (_t and hmac.compare_digest(_t, _TOKEN or ''))
        )
        if not ok:
            _sec_log(f"DENY path={path} user={repr(u)} ip={request.client.host if request.client else '?'}")
            return Response("Unauthorized", status_code=401)
        return await call_next(request)

# ==== APP ====
app = FastAPI(title="Task API")
_METRICS = {}
app.add_middleware(_BasicAuthMW)

@app.get("/health")
def _health(): return {"status": "ok"}

@app.get("/tasks/ping")
def _ping(): return {"ok": True}

@app.get("/metrics")
def _metrics():
    # TODO: подключить реальные метрики OCR
    return {
        "total": 21,
        "ok": 14,
        "skip": 7,
        "fail": 0,
        "success_rate": 66.67,
        "avg_ocr_time_sec": None
    }

@app.get("/reports/list")
def _reports_list(
    limit: int = Query(50, ge=1, le=200, description="Количество элементов (1..200)"),
    date_from: str | None = None,
    date_to: str | None = None,
    status: str | None = None,
    offset: int = Query(0, ge=0, description="Смещение (пагинация)")
):
    """Возвращает список OCR-отчётов с фильтрами и пагинацией.

    Параметры:
      - limit: размер страницы (1..200)
      - offset: смещение от начала списка (>=0)
      - status: фильтр статуса (например, "ok")
      - date_from/date_to: ISO8601-строки (yyyy-mm-dd или yyyy-mm-ddTHH:MM:SS)
    """
    return _list_reports(limit=limit, date_from=date_from, date_to=date_to, status=status, offset=offset)

def _list_reports(limit=100, date_from=None, date_to=None, status=None, offset=0):
    # Безопасный список отчётов с поддержкой REPORTS_DIR и фильтрами
    import datetime as _dt
    from pathlib import Path as _Path

    # Каталог отчётов: глобальная REPORTS -> $REPORTS_DIR -> дефолт
    base = globals().get("REPORTS")
    if base is None:
        base = os.environ.get("REPORTS_DIR") or (_Path(__file__).resolve().parent.parent / "reports" / "ocr")
    base = _Path(base)

    if not base.exists():
        return []

    def _parse_iso(x):
        try:
            return _dt.datetime.fromisoformat(x) if x else None
        except Exception:
            return None

    df = _parse_iso(date_from)
    dt_ = _parse_iso(date_to)

    rows = []
    for rep in base.iterdir():
        if not rep.is_dir():
            continue
        try:
            ts = _dt.datetime.fromtimestamp(rep.stat().st_mtime)
        except Exception:
            ts = None

        if df and ts and ts < df:
            continue
        if dt_ and ts and ts > dt_:
            continue

        has_parsed = (rep / "parsed.json").exists()
        has_text = (rep / "text.txt").exists() or (rep / "normalized.txt").exists()
        st = "ok" if has_parsed else "skip"
        if status and st != status:
            continue

        rows.append({
            "id": rep.name,
            "ts": ts.isoformat() if hasattr(ts, "isoformat") else None,
            "status": st,
            "path": str(rep),
            "has_parsed": has_parsed,
            "has_text": has_text,
        })

    rows.sort(key=lambda x: x["ts"] or "", reverse=True)

    try:
        limit = int(limit)
    except Exception:
        limit = 100
    limit = max(1, min(200, limit))
    return rows[offset:offset+limit]

# --- GET /reports/{id} ---
def _report_get(report_id: str):
    """Возвращает метаданные одного отчёта (по имени папки)."""
    import os, json, datetime as _dt
    from pathlib import Path as _Path

    # валидация id: только безопасные символы
    if not re.match(r'^[A-Za-z0-9_\-:]+$', report_id or ""):
        raise HTTPException(status_code=400, detail="invalid report_id")

    # корень: REPORTS (глобал) -> $REPORTS_DIR -> дефолт
    base = globals().get("REPORTS")
    if base is None:
        base = os.environ.get("REPORTS_DIR") or (_Path(__file__).resolve().parent.parent / "reports" / "ocr")
    base = _Path(base)

    rep = base / report_id
    try:
        rep = rep.resolve()
        base = base.resolve()
    except Exception:
        raise HTTPException(status_code=400, detail="bad path")

    # защитимся от directory traversal
    if base not in rep.parents and rep != base:
        raise HTTPException(status_code=400, detail="out of base path")

    if not rep.exists() or not rep.is_dir():
        raise HTTPException(status_code=404, detail="report not found")

    # стат и ts
    try:
        ts = _dt.datetime.fromtimestamp(rep.stat().st_mtime).isoformat()
    except Exception:
        ts = None

    # артефакты
    parsed = rep / "parsed.json"
    norm   = rep / "normalized.txt"
    textf  = rep / "text.txt"

    # статус
    has_parsed = parsed.exists()
    has_text = textf.exists() or norm.exists()
    status = "ok" if has_parsed else ("skip" if has_text else "skip")

    # полезные поля из parsed.json (если есть)
    extras = {}
    if has_parsed:
        try:
            with parsed.open("r", encoding="utf-8") as fh:
                pj = json.load(fh)
            # вытащим часто нужное
            for k in ("store","total","currency","date","confidence","pages","used_lang","requested_lang","lang","duration_sec"):
                if k in pj:
                    extras[k] = pj[k]
        except Exception:
            pass

    # «подсказки-ссылки»: просто имена файлов и абсолютные пути
    artifacts = {
        "parsed_json": str(parsed) if has_parsed else None,
        "text_txt": str(textf) if textf.exists() else None,
        "normalized_txt": str(norm) if norm.exists() else None,
    }

    return {
        "id": report_id,
        "path": str(rep),
        "ts": ts,
        "status": status,
        "has_parsed": has_parsed,
        "has_text": has_text,
        "artifacts": artifacts,
        **extras
    }

@app.get("/reports/{report_id}", summary="Get report metadata", description="Возвращает метаданные и артефакты одного OCR-отчёта.")
def reports_get(report_id: str):
    return _report_get(report_id)

ALLOWED_ARTIFACTS = {
    "parsed.json": "application/json",
    "text.txt": "text/plain; charset=utf-8",
    "normalized.txt": "text/plain; charset=utf-8",
}

@app.get("/reports/{report_id}/artifact", summary="Download report artifact",
         description="Скачивание одного из артефактов отчёта: parsed.json | text.txt | normalized.txt")
def report_artifact(report_id: str, name: str):
    import os
    from pathlib import Path as _Path
    # валидация id и имени файла
    if not re.match(r'^[A-Za-z0-9_\-:]+$', report_id or ""):
        raise HTTPException(status_code=400, detail="invalid report_id")
    if name not in ALLOWED_ARTIFACTS:
        raise HTTPException(status_code=400, detail="invalid artifact name")

    base = globals().get("REPORTS")
    if base is None:
        base = os.environ.get("REPORTS_DIR") or (_Path(__file__).resolve().parent.parent / "reports" / "ocr")
    base = _Path(base)
    rep = (base / report_id).resolve()
    base = base.resolve()
    if base not in rep.parents and rep != base:
        raise HTTPException(status_code=400, detail="out of base path")
    if not rep.exists() or not rep.is_dir():
        raise HTTPException(status_code=404, detail="report not found")

    f = rep / name
    if not f.exists() or not f.is_file():
        raise HTTPException(status_code=404, detail="artifact not found")

    media = ALLOWED_ARTIFACTS[name]
    return FileResponse(path=str(f), media_type=media, filename=name)

@app.head("/reports/{report_id}/artifact", summary="HEAD for artifact (headers only)")
def report_artifact_head(report_id: str, name: str, request: Request):
    # используем ту же проверку, что и в GET-обработчике
    import os, re
    from pathlib import Path as _Path
    if not re.match(r'^[A-Za-z0-9_\-:]+$', report_id or ""):
        raise HTTPException(status_code=400, detail="invalid report_id")
    if name not in ALLOWED_ARTIFACTS:
        raise HTTPException(status_code=400, detail="invalid artifact name")

    base = globals().get("REPORTS")
    if base is None:
        base = os.environ.get("REPORTS_DIR") or (_Path(__file__).resolve().parent.parent / "reports" / "ocr")
    base = _Path(base)
    rep = (base / report_id).resolve(); base = base.resolve()
    if base not in rep.parents and rep != base:
        raise HTTPException(status_code=400, detail="out of base path")
    if not rep.exists() or not rep.is_dir():
        raise HTTPException(status_code=404, detail="report not found")

    f = rep / name
    if not f.exists() or not f.is_file():
        raise HTTPException(status_code=404, detail="artifact not found")

    media = ALLOWED_ARTIFACTS[name]
    # только заголовки, без тела
    headers = {
        "Content-Type": media,
        "Content-Length": str(f.stat().st_size),
        "Content-Disposition": f'attachment; filename="{name}"',
    }
    return Response(status_code=200, headers=headers)

@app.middleware('http')
async def _obs_mw(request, call_next):
    return await call_next(request)

# ==== ROUTE: /report_pack (enqueue task) ====
from typing import Optional
import time, json
from pathlib import Path
from fastapi import Query
@app.get("/report_pack", summary="Enqueue report_pack task")
async def route_report_pack(request: Request, count: int = Query(1, ge=1, le=50)):
    _route_guard_basic(request)
    base = Path(__file__).resolve().parent.parent
    inbox = base / "tasks" / "inbox"
    inbox.mkdir(parents=True, exist_ok=True)
    ts = int(time.time())
    name = time.strftime("task_%Y%m%d_%H%M%S_report_pack.json", time.localtime(ts))
    payload = {"kind": "report_pack", "count": int(count), "ts": ts}
    (inbox / name).write_text(json.dumps(payload, ensure_ascii=False), encoding="utf-8")
    return {"queued": f"tasks/inbox/{name}"}

# ==== SIMPLE ROUTE GUARD (no Depends) ====
import base64, os
def _route_guard_basic(request: Request):
    user = os.getenv("TASK_API_BASIC_USER","lsa")
    pw   = os.getenv("TASK_API_BASIC_PASS","changeme")
    h = request.headers.get("Authorization","")
    if h.lower().startswith("basic "):
        try:
            u,p = base64.b64decode(h.split(" ",1)[1]).decode(errors="ignore").split(":",1)
            if u==user and p==pw:
                return True
        except Exception:
            pass
    raise HTTPException(status_code=401, detail="Unauthorized",
                        headers={"WWW-Authenticate": "Basic realm=\"Local Task API\""})
# === DEBUG_WHERE_START ===
from fastapi import Query
from pathlib import Path
import os, time

@app.get("/debug/where", summary="Show cwd/base/env and optionally touch inbox")
def debug_where(touch: int = Query(default=0, ge=0, le=1)):
    # корень проекта = ../ от bin/task_api.py
    base_dir = Path(__file__).resolve().parent.parent
    cwd = Path.cwd().resolve()
    inbox = base_dir / "tasks" / "inbox"
    probe = inbox / "touch_from_api.debug"

    if touch:
        inbox.mkdir(parents=True, exist_ok=True)
        probe.write_text(str(time.time()))

    return {
        "cwd": str(cwd),
        "base_dir": str(base_dir),
        "inbox": str(inbox),
        "probe": str(probe),
        "inbox_exists": inbox.exists(),
        "probe_exists": probe.exists(),
        "env_user": os.getenv("TASK_API_BASIC_USER"),
        "env_pass_len": len(os.getenv("TASK_API_BASIC_PASS","")),
    }
# === DEBUG_WHERE_END ===
# === DEBUG_WHERE_START ===
from fastapi import Query
from pathlib import Path
import os, time

@app.get("/debug/where", summary="Show cwd/base/env and optionally touch inbox")
def debug_where(touch: int = Query(default=0, ge=0, le=1)):
    # корень проекта = ../ от bin/task_api.py
    base_dir = Path(__file__).resolve().parent.parent
    cwd = Path.cwd().resolve()
    inbox = base_dir / "tasks" / "inbox"
    probe = inbox / "touch_from_api.debug"

    if touch:
        inbox.mkdir(parents=True, exist_ok=True)
        probe.write_text(str(time.time()))

    return {
        "cwd": str(cwd),
        "base_dir": str(base_dir),
        "inbox": str(inbox),
        "probe": str(probe),
        "inbox_exists": inbox.exists(),
        "probe_exists": probe.exists(),
        "env_user": os.getenv("TASK_API_BASIC_USER"),
        "env_pass_len": len(os.getenv("TASK_API_BASIC_PASS","")),
    }
# === DEBUG_WHERE_END ===
# === DEBUG_WHERE_START ===
from fastapi import Query
from pathlib import Path
import os, time

@app.get("/debug/where", summary="Show cwd/base/env and optionally touch inbox")
def debug_where(touch: int = Query(default=0, ge=0, le=1)):
    # корень проекта = ../ от bin/task_api.py
    base_dir = Path(__file__).resolve().parent.parent
    cwd = Path.cwd().resolve()
    inbox = base_dir / "tasks" / "inbox"
    probe = inbox / "touch_from_api.debug"

    if touch:
        inbox.mkdir(parents=True, exist_ok=True)
        probe.write_text(str(time.time()))

    return {
        "cwd": str(cwd),
        "base_dir": str(base_dir),
        "inbox": str(inbox),
        "probe": str(probe),
        "inbox_exists": inbox.exists(),
        "probe_exists": probe.exists(),
        "env_user": os.getenv("TASK_API_BASIC_USER"),
        "env_pass_len": len(os.getenv("TASK_API_BASIC_PASS","")),
    }
# === DEBUG_WHERE_END ===
# === DEBUG_WHERE_START ===
from fastapi import Query
from pathlib import Path
import os, time

@app.get("/debug/where", summary="Show cwd/base/env and optionally touch inbox")
def debug_where(touch: int = Query(default=0, ge=0, le=1)):
    # корень проекта = ../ от bin/task_api.py
    base_dir = Path(__file__).resolve().parent.parent
    cwd = Path.cwd().resolve()
    inbox = base_dir / "tasks" / "inbox"
    probe = inbox / "touch_from_api.debug"

    if touch:
        inbox.mkdir(parents=True, exist_ok=True)
        probe.write_text(str(time.time()))

    return {
        "cwd": str(cwd),
        "base_dir": str(base_dir),
        "inbox": str(inbox),
        "probe": str(probe),
        "inbox_exists": inbox.exists(),
        "probe_exists": probe.exists(),
        "env_user": os.getenv("TASK_API_BASIC_USER"),
        "env_pass_len": len(os.getenv("TASK_API_BASIC_PASS","")),
    }
# === DEBUG_WHERE_END ===
