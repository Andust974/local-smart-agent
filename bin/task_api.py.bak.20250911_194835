from fastapi import FastAPI
import os

app = FastAPI()

@app.get("/health")
def _health():
    return {"status": "ok"}

if __name__ == "__main__":
    import uvicorn
    host = os.getenv("TASK_API_HOST", "127.0.0.1")
    port = int(os.getenv("TASK_API_PORT", "8766"))
    uvicorn.run(app, host=host, port=port)

# ===== BASIC_AUTH_MW BEGIN =====
import os, base64, hmac
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.responses import Response, JSONResponse
from starlette.status import HTTP_401_UNAUTHORIZED
from starlette.requests import Request
from fastapi import FastAPI

# гарантируем наличие app
try:
    app  # type: ignore
except NameError:
    app = FastAPI()

# переменные окружения из systemd drop-in
_BUSER = os.getenv("TASK_API_BASIC_USER", "")
_BPASS = os.getenv("TASK_API_BASIC_PASS", "")

# белый список (всегда открыто)
_WHITELIST_EXACT = {"/", "/health", "/openapi.json", "/docs", "/docs/"}
_WHITELIST_PREFIX = ("/reports", "/static", "/assets")

# защищаем только write/queue-зону
_PROTECTED_PREFIX = ("/enqueue", "/report_pack", "/task", "/tasks")

def _whitelisted(path: str) -> bool:
    return path in _WHITELIST_EXACT or any(path.startswith(p) for p in _WHITELIST_PREFIX)

def _needs_auth(path: str) -> bool:
    return (not _whitelisted(path)) and any(path.startswith(p) for p in _PROTECTED_PREFIX)

def _parse_basic(h):
    if not h or not str(h).lower().startswith("basic "): return (None,None)
    try:
        u,p = base64.b64decode(str(h).split(" ",1)[1]).decode("utf-8").split(":",1)
        return u,p
    except Exception:
        return (None,None)

class _BasicAuthMW(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        path = request.url.path
        if not _needs_auth(path):
            return await call_next(request)
        u,p = _parse_basic(request.headers.get("authorization"))
        ok = (u is not None
              and hmac.compare_digest(u, _BUSER or "")
              and hmac.compare_digest(p or "", _BPASS or ""))
        if not ok:
            return Response("Unauthorized", status_code=HTTP_401_UNAUTHORIZED,
                            headers={"WWW-Authenticate": 'Basic realm="task-api"'})
        return await call_next(request)

app.add_middleware(_BasicAuthMW)

# тестовый защищённый маршрут
@app.get("/tasks/ping")
def _tasks_ping():
    return {"ok": True}
# ===== BASIC_AUTH_MW END =====
