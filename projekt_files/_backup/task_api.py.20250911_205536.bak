from fastapi.middleware.cors import CORSMiddleware
from fastapi import FastAPI
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.responses import Response
from starlette.requests import Request
from starlette.status import HTTP_401_UNAUTHORIZED
import os, base64, hmac, time

app = FastAPI()
app.add_middleware(CORSMiddleware, allow_origins=["http://127.0.0.1:8777"], allow_methods=["*"], allow_headers=["*"], allow_credentials=False)

@app.get("/health")
def _health():
    return {"status": "ok"}

# security log
SEC_LOG = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", "logs", "security.log"))
def _sec_log(line: str) -> None:
    try:
        ts = time.strftime("%Y-%m-%dT%H:%M:%S%z")
        os.makedirs(os.path.dirname(SEC_LOG), exist_ok=True)
        with open(SEC_LOG, "a", encoding="utf-8") as f:
            f.write(f"{ts} {line}\n")
    except Exception:
        pass

# BasicAuth
_BUSER = os.getenv("TASK_API_BASIC_USER", "")
_BPASS = os.getenv("TASK_API_BASIC_PASS", "")
_WHITELIST_EXACT = {"/", "/health", "/openapi.json", "/docs", "/docs/"}
_WHITELIST_PREFIX = ("/reports", "/static", "/assets")
_PROTECTED_PREFIX = ("/enqueue", "/report_pack", "/task", "/tasks")

def _wl(p: str) -> bool:
    return p in _WHITELIST_EXACT or any(p.startswith(x) for x in _WHITELIST_PREFIX)
def _needs_auth(p: str) -> bool:
    return (not _wl(p)) and any(p.startswith(x) for x in _PROTECTED_PREFIX)
def _parse_basic(h: str | None):
    if not h or not h.lower().startswith("basic "): return (None, None)
    try:
        u, p = base64.b64decode(h.split(" ", 1)[1]).decode("utf-8").split(":", 1)
        return u, p
    except Exception:
        return (None, None)

class _BasicAuthMW(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        path = request.url.path
        if not _needs_auth(path):
            return await call_next(request)
        u, p = _parse_basic(request.headers.get("authorization"))
        ok = (u is not None
              and hmac.compare_digest(u, _BUSER or "")
              and hmac.compare_digest(p or "", _BPASS or ""))
        if not ok:
            _sec_log(f"DENY path={path} user={repr(u)} ip={request.client.host if request.client else '?'}")
            return Response("Unauthorized", status_code=HTTP_401_UNAUTHORIZED,
                            headers={"WWW-Authenticate": 'Basic realm="task-api"'})
        _sec_log(f"ALLOW path={path} user={repr(u)} ip={request.client.host if request.client else '?'}")
        return await call_next(request)

app.add_middleware(_BasicAuthMW)

@app.get("/tasks/ping")
def _tasks_ping():
    return {"ok": True}

from pathlib import Path
import os, json, datetime as dt
PRJ = Path(os.path.expanduser("~/ai-agent/projects/local_smart_agent"))
REPORTS = PRJ / "reports" / "ocr"

def _ts_of_dir(d: Path):
    try: return dt.datetime.strptime(d.name[:15], "%Y%m%d_%H%M%S")
    except: return dt.datetime.fromtimestamp(d.stat().st_mtime)

def _status(rep: Path):
    if (rep/"parsed.json").exists(): return "ok"
    if not (rep/"text.txt").exists(): return "skip"
    return "fail"

def _list_reports(limit=100, date_from=None, date_to=None, status=None):
    if not REPORTS.exists(): return []
    df = dt.datetime.fromisoformat(date_from) if date_from else None
    dt_ = dt.datetime.fromisoformat(date_to) if date_to else None
    out=[]
    for d in sorted([p for p in REPORTS.iterdir() if p.is_dir()], key=_ts_of_dir, reverse=True):
        t=_ts_of_dir(d)
        if df and t<df: continue
        if dt_ and t>dt_: continue
        st=_status(d)
        if status and st!=status: continue
        out.append({"id":d.name,"ts":t.isoformat(),"status":st,"path":str(d),
                    "has_parsed":(d/'parsed.json').exists(),"has_text":(d/'text.txt').exists()})
        if len(out)>=limit: break
    return out

@app.get("/metrics")
def _metrics(date_from: str|None=None, date_to: str|None=None):
    rs=_list_reports(limit=1000,date_from=date_from,date_to=date_to)
    total=len(rs); ok=sum(r["status"]=="ok" for r in rs); skip=sum(r["status"]=="skip" for r in rs); fail=total-ok-skip
    rate=round((ok/total)*100,2) if total else 0.0
    return {"total":total,"ok":ok,"skip":skip,"fail":fail,"success_rate":rate,"avg_ocr_time_sec":None}

@app.get("/reports/list")
def _reports_list(limit: int=100, status: str|None=None, date_from: str|None=None, date_to: str|None=None):
    return _list_reports(limit=limit,status=status,date_from=date_from,date_to=date_to)
if __name__ == "__main__":
    import uvicorn
    host = os.getenv("TASK_API_HOST", "127.0.0.1")
    port = int(os.getenv("TASK_API_PORT", "8766"))
    uvicorn.run(app, host=host, port=port)
