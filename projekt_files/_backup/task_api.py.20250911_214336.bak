#!/usr/bin/env python3
import os, hmac, json, datetime as dt
from pathlib import Path
from fastapi import FastAPI, Request, Query
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.responses import Response

# ==== CONFIG ====
_BUSER = os.getenv("TASK_API_BASIC_USER", "lsa")
_BPASS = os.getenv("TASK_API_BASIC_PASS", "changeme")

# ==== BASIC AUTH ====
def _parse_bearer(h: str|None):
    if not h: return None
    h=h.strip()
    if h.lower().startswith('bearer '): return h.split(' ',1)[1]
    if h.lower().startswith('token '):  return h.split(' ',1)[1]
    return None


def _parse_basic(auth):
    if not auth or not auth.lower().startswith("basic "):
        return None, None
    import base64
    try:
        u, p = base64.b64decode(auth.split()[1]).decode().split(":", 1)
        return u, p
    except Exception:
        return None, None

def _needs_auth(path: str) -> bool:
    # allow health/ping + metrics + reports/list without auth (dev)
    if path.startswith("/health") or path.startswith("/tasks/ping") or path.startswith("/metrics") or path.startswith("/reports/list"):
        return False

def _sec_log(msg): print(msg, flush=True)

_RL_BUCKETS = defaultdict(lambda: deque())
_RATE_LIMIT = int(os.getenv('TASK_API_RATE_PER_MIN','10'))

class _BasicAuthMW(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        path = request.url.path
        if not _needs_auth(path):
            return await call_next(request)
        authh = request.headers.get('authorization')
        u, p = _parse_basic(authh)
        _t = _parse_bearer(authh)
        # rate-limit
        now=time.time(); ip=(request.client.host if request.client else '?')
        q=_RL_BUCKETS[ip];
        while q and now-q[0]>60: q.popleft()
        q.append(now)
        if len(q) > _RATE_LIMIT:
            _sec_log(f'RLIMIT path={path} ip={ip} n={len(q)}')
            return Response('Too Many Requests', status_code=429)
        ok = (
            (u is not None and hmac.compare_digest(u, _BUSER or '') and hmac.compare_digest(p or '', _BPASS or ''))
            or (_t and hmac.compare_digest(_t, _TOKEN or ''))
        )
        if not ok:
            _sec_log(f"DENY path={path} user={repr(u)} ip={request.client.host if request.client else '?'}")
            return Response("Unauthorized", status_code=401)
        return await call_next(request)

# ==== APP ====
app = FastAPI(title="Task API")
app.add_middleware(_BasicAuthMW)

@app.get("/health")
def _health(): return {"status": "ok"}

@app.get("/tasks/ping")
def _ping(): return {"ok": True}

@app.get("/metrics")
def _metrics():
    # TODO: подключить реальные метрики OCR
    return {
        "total": 21,
        "ok": 14,
        "skip": 7,
        "fail": 0,
        "success_rate": 66.67,
        "avg_ocr_time_sec": None
    }

@app.get("/reports/list")
def _reports_list(limit: int = Query(100, le=200)):
    base = Path.home() / "ai-agent/projects/local_smart_agent/reports/ocr"
    if not base.exists():
        return []
    out = []
    for d in sorted([p for p in base.iterdir() if p.is_dir()],
                    key=lambda p: d.name, reverse=True)[:limit]:
        ts = dt.datetime.fromtimestamp(d.stat().st_mtime).isoformat()
        rec = {
            "id": d.name,
            "ts": ts,
            "status": "ok",
            "path": str(d),
            "has_parsed": (d / "parsed.json").exists(),
            "has_text": (d / "text.txt").exists()
        }
        meta = d / "meta.json"
        if meta.exists():
            try:
                rec.update(json.loads(meta.read_text()))
            except Exception:
                pass
        out.append(rec)
    return out

if __name__ == "__main__":
    import uvicorn
    host = os.getenv("TASK_API_HOST", "127.0.0.1")
    port = int(os.getenv("TASK_API_PORT", "8766"))
    uvicorn.run(app, host=host, port=port)
