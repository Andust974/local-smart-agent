#!/usr/bin/env python3
import os, json, datetime as dt
from pathlib import Path
from fastapi import FastAPI, Query
from fastapi.responses import JSONResponse
import uvicorn

PRJ = Path(os.path.expanduser("~/ai-agent/projects/local_smart_agent"))
REPORTS = PRJ / "reports" / "ocr"

app = FastAPI(title="Local Smart Agent API")

def parse_dt(s: str):
    try: return dt.datetime.fromisoformat(s)
    except: return None

def report_status(rep: Path):
    txt = rep / "text.txt"
    parsed = rep / "parsed.json"
    if parsed.exists(): return "ok"
    if not txt.exists(): return "skip"
    return "fail"

def list_reports(limit: int=100, date_from: str|None=None, date_to: str|None=None, status: str|None=None):
    if not REPORTS.exists(): return []
    items = []
    df = parse_dt(date_from) if date_from else None
    dt_ = parse_dt(date_to) if date_to else None
    for d in sorted([p for p in REPORTS.iterdir() if p.is_dir()], key=lambda p: p.name, reverse=True):
        # попытка вытащить дату из имени YYYYmmdd_HHMMSS
        ts = None
        try:
            ts = dt.datetime.strptime(d.name[:15], "%Y%m%d_%H%M%S")
        except:
            ts = dt.datetime.fromtimestamp(d.stat().st_mtime)
        if df and ts < df: continue
        if dt_ and ts > dt_: continue
        st = report_status(d)
        if status and st != status: continue
        items.append({
            "id": d.name,
            "path": str(d),
            "status": st,
            "ts": ts.isoformat(),
            "has_parsed": (d/"parsed.json").exists(),
            "has_text": (d/"text.txt").exists(),
        })
        if len(items) >= limit: break
    return items

@app.get("/health")
def health():
    return {"status":"ok"}

@app.get("/metrics")
def metrics(date_from: str|None=None, date_to: str|None=None):
    reps = list_reports(limit=1000, date_from=date_from, date_to=date_to)
    total = len(reps)
    ok = sum(1 for r in reps if r["status"]=="ok")
    skip = sum(1 for r in reps if r["status"]=="skip")
    fail = sum(1 for r in reps if r["status"]=="fail")
    rate = (ok/total)*100 if total else 0.0
    # avg_time пока неизвестно — вернём null (реализуем позже, когда появятся метки времени стадий)
    return JSONResponse({
        "total": total, "ok": ok, "skip": skip, "fail": fail, "success_rate": round(rate,2),
        "avg_ocr_time_sec": None
    })

@app.get("/reports/list")
def reports_list(limit: int=100,
                 status: str|None = Query(default=None, pattern="^(ok|fail|skip)$"),
                 date_from: str|None=None, date_to: str|None=None):
    return JSONResponse(list_reports(limit=limit, date_from=date_from, date_to=date_to, status=status))

if __name__ == "__main__":
    uvicorn.run(app, host="127.0.0.1", port=8766)
