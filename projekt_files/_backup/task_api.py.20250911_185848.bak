from fastapi import FastAPI
from fastapi.responses import JSONResponse
import os

app = FastAPI()

@app.get("/health")
def health(token: str | None = None):
    tok = os.getenv("TASK_API_TOKEN", "changeme")
    if tok and token != tok:
        return JSONResponse({"error": "unauthorized"}, status_code=401)
    return {"status": "ok"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="127.0.0.1", port=int(os.getenv("TASK_API_PORT","8766")))

# ===== BASIC_AUTH_MIDDLEWARE BEGIN =====
import os, base64, hmac
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.responses import Response, JSONResponse
from starlette.status import HTTP_401_UNAUTHORIZED
from starlette.requests import Request

# Env-переменные (см. systemd drop-in)
_BUSER = os.getenv("TASK_API_BASIC_USER", "")
_BPASS = os.getenv("TASK_API_BASIC_PASS", "")
_HOST  = os.getenv("TASK_API_HOST", "127.0.0.1")  # может использоваться самим приложением при старте

# Явный белый список путей (всегда открыты)
_WHITELIST_EXACT = {"/health", "/openapi.json", "/docs", "/docs/", "/"}
_WHITELIST_PREFIX = ("/reports", "/static", "/assets")

# Защищаем только write/queue
_PROTECTED_PREFIX = ("/enqueue", "/report_pack", "/task", "/tasks")

def _path_whitelisted(path: str) -> bool:
    return path in _WHITELIST_EXACT or any(path.startswith(p) for p in _WHITELIST_PREFIX)

def _needs_auth(path: str) -> bool:
    # health и openapi остаются открытыми
    if _path_whitelisted(path):
        return False
    return any(path.startswith(p) for p in _PROTECTED_PREFIX)

def _parse_basic(auth_header):
    if not auth_header or not str(auth_header).lower().startswith("basic "):
        return None, None
    try:
        decoded = base64.b64decode(str(auth_header).split(" ", 1)[1]).decode("utf-8")
        user, pwd = decoded.split(":", 1)
        return user, pwd
    except Exception:
        return None, None

class _BasicAuthMW(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        path = request.url.path
        if not _needs_auth(path):
            return await call_next(request)
        user, pwd = _parse_basic(request.headers.get("authorization"))
        ok = (
            user is not None
            and hmac.compare_digest(user, _BUSER or "")
            and hmac.compare_digest(pwd or "", _BPASS or "")
        )
        if not ok:
            return Response(
                "Unauthorized",
                status_code=HTTP_401_UNAUTHORIZED,
                headers={"WWW-Authenticate": 'Basic realm="task-api"'},
            )
        return await call_next(request)

try:
    app  # type: ignore[name-defined]
    app.add_middleware(_BasicAuthMW)

    # Тестовый защищённый эндпоинт (для проверки 401/200)
    @app.get("/tasks/ping")
    def tasks_ping():
        return {"ok": True}
except NameError:
    # Если app ещё не объявлен — пропускаем (в твоей сборке app объявлен раньше)
    pass
# ===== BASIC_AUTH_MIDDLEWARE END =====

