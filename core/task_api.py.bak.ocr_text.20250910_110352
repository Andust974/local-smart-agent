from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
import os, glob, json, time

app = FastAPI(title="Local Smart Agent API", version="1.0")


# CORS: разрешим локальные запросы UI
app.add_middleware(CORSMiddleware, allow_origins=['*'], allow_methods=['*'], allow_headers=['*'])

# Раздаём статику дашборда по /ui/
import os
ui_dir = os.path.join(os.path.expanduser('~'), 'ai-agent','projects','local_smart_agent','ui')
if os.path.isdir(ui_dir):
    app.mount('/ui', StaticFiles(directory=ui_dir, html=True), name='ui')
# --- helpers ---
def _root():
    return os.path.expanduser("~/ai-agent/projects/local_smart_agent")

# --- health ---
@app.get("/health")
def health():
    return {"status": "ok"}

# --- enqueue OCR task ---
@app.post("/enqueue/ocr")
def enqueue_ocr(path: str, lang: str = "eng+rus+pol"):
    root = _root()
    inbox = os.path.join(root, "tasks", "inbox")
    os.makedirs(inbox, exist_ok=True)
    ts = time.strftime("%Y%m%d_%H%M%S")
    # относительный путь относительно корня проекта
    if path.startswith(("sandbox/", "reports/", "tasks/")):
        rel = path
    else:
        try:
            rel = os.path.relpath(path, root)
        except Exception:
            rel = path
    lang = (lang or "eng+rus+pol").replace(" ", "+").replace("%20","+")
    payload = {"kind": "ocr_scan", "path": rel, "lang": lang}
    fn = os.path.join(inbox, f"task_{ts}_ocr.json")
    with open(fn, "w", encoding="utf-8") as f:
        json.dump(payload, f, ensure_ascii=False)
    return {"status": "queued", "task": os.path.basename(fn)}

# --- list OCR reports ---
@app.get("/reports/ocr/list")
def ocr_list(limit: int = 20):
    root = _root()
    base = os.path.join(root, "reports", "ocr")
    if not os.path.isdir(base):
        return []
    dirs = sorted(glob.glob(os.path.join(base, "*/")), reverse=True)[:limit]
    out = []
    for d in dirs:
        meta_p = os.path.join(d, "meta.json")
        try:
            m = json.load(open(meta_p, encoding="utf-8")) if os.path.exists(meta_p) else {}
        except Exception:
            m = {"status": "error", "errors": ["bad meta.json"]}
        out.append({
            "id": os.path.basename(os.path.normpath(d)),
            "dir": os.path.relpath(d, root),
            "status": m.get("status", "unknown"),
            "pages": m.get("pages"),
            "lang": m.get("lang"),
            "duration_sec": m.get("duration_sec"),
        })
    return out

# --- latest OCR report ---
@app.get("/reports/ocr/latest")
def ocr_latest():
    root = _root()
    base = os.path.join(root, "reports", "ocr")
    if not os.path.isdir(base):
        raise HTTPException(status_code=404, detail="no ocr reports")
    dirs = sorted(glob.glob(os.path.join(base, "*/")), reverse=True)
    if not dirs:
        raise HTTPException(status_code=404, detail="no ocr reports")
    d = dirs[0]
    meta_p = os.path.join(d, "meta.json")
    text_p = os.path.join(d, "text.txt")
    try:
        meta = json.load(open(meta_p, encoding="utf-8")) if os.path.exists(meta_p) else {}
    except Exception:
        meta = {"status": "error", "errors": ["bad meta.json"]}
    text_head = ""
    if os.path.exists(text_p):
        try:
            with open(text_p, "r", encoding="utf-8") as f:
                # первые 20 строк
                for i, line in enumerate(f):
                    if i >= 20: break
                    text_head += line
        except Exception:
            text_head = ""
    return {"dir": os.path.relpath(d, root), "meta": meta, "text_head": text_head}
