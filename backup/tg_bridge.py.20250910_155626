#!/usr/bin/env python3
import os, json, time, urllib.request, urllib.parse, pathlib

BASE = pathlib.Path(__file__).resolve().parents[1]
DATA = BASE / "data" / "tg_bridge"
LOGF = os.getenv("TG_LOG_FILE", "logs/tg_bridge.log")
DATA.mkdir(parents=True, exist_ok=True)
(pathlib.Path(LOGF).parent).mkdir(parents=True, exist_ok=True)

BOT_TOKEN = os.getenv("TG_BOT_TOKEN","")
API_BASE = f"https://api.telegram.org/bot{BOT_TOKEN}"
AGENT_PORT = int(os.getenv("TASK_API_PORT","8766"))
AGENT_TOKEN = os.getenv("TASK_API_TOKEN","changeme")

PIN_FILE = DATA / "pin.txt"
STATE_FILE = DATA / "authorized.json"

def log(msg):
    ts = time.strftime("%Y-%m-%d %H:%M:%S")
    with open(LOGF,"a",encoding="utf-8") as f:
        f.write(f"{ts} {msg}\n")

def http_get(url, params=None, timeout=30):
    if params:
        url += "?" + urllib.parse.urlencode(params)
    with urllib.request.urlopen(url, timeout=timeout) as r:
        return r.read()

def tg_send(chat_id, text):
    body = urllib.parse.urlencode({"chat_id":chat_id,"text":text}).encode()
    req = urllib.request.Request(API_BASE + "/sendMessage", data=body)
    urllib.request.urlopen(req, timeout=30).read()

def load_state():
    return json.loads(STATE_FILE.read_text()) if STATE_FILE.exists() else {"authorized":[]}

def save_state(st):
    STATE_FILE.write_text(json.dumps(st))

def is_auth(chat_id, st):
    return chat_id in st.get("authorized",[])

def check_pin(pin):
    if not PIN_FILE.exists():
        return False
    ok = PIN_FILE.read_text().strip() == pin.strip()
    if ok:
        try:
            PIN_FILE.unlink()
        except:
            pass
    return ok

def agent_health():
    url = f"http://127.0.0.1:{AGENT_PORT}/health?token={urllib.parse.quote(AGENT_TOKEN)}"
    with urllib.request.urlopen(url, timeout=20) as r:
        return r.read().decode()

def handle(msg):
    chat_id = msg["chat"]["id"]
    text = (msg.get("text") or "").strip()
    st = load_state()

    if text.startswith("/start"):
        parts = text.split()
        if len(parts)==2 and check_pin(parts[1]):
            if chat_id not in st["authorized"]:
                st["authorized"].append(chat_id)
                save_state(st)
            tg_send(chat_id, "✅ Связь установлена. Команда: /health")
        else:
            tg_send(chat_id, "Отправь: /start PIN (PIN сгенерируй на сервере).")
        return

    if not is_auth(chat_id, st):
        tg_send(chat_id, "⛔ Нет доступа. Используй /start PIN")
        return

    if text.startswith("/health"):
        try:
            tg_send(chat_id, "OK: " + agent_health())
        except Exception as e:
            tg_send(chat_id, "ERR: " + str(e))
        return


    if text.startswith("/bundle"):
        n = 1
        parts = text.split()
        if len(parts) >= 2 and parts[1].isdigit():
            n = max(1, int(parts[1]))
        try:
            resp = agent_call("/report_pack", {"count": n})
            tg_send(chat_id, "queued: " + resp)
        except Exception as e:
            tg_send(chat_id, "ERR: " + str(e))
        return


    if text.startswith("/latest"):
        try:
            raw = urllib.request.urlopen(f"http://127.0.0.1:{AGENT_PORT}/reports/list.json", timeout=20).read().decode()
            items = json.loads(raw).get("items", [])
            if not items:
                tg_send(chat_id, "reports пусто"); return
            latest = items[0]["name"]
            # если файл небольшой — можно отправить документом; иначе даём ссылку
            path = (BASE / "reports" / latest)
            if path.exists() and path.stat().st_size < 45_000_000:
                # простой multipart мы пока не внедряли в этой версии → отправим ссылкой
                url = f"http://127.0.0.1:{AGENT_PORT}/reports/" + urllib.parse.quote(latest)
                tg_send(chat_id, url)
            else:
                url = f"http://127.0.0.1:{AGENT_PORT}/reports/" + urllib.parse.quote(latest)
                tg_send(chat_id, url)
        except Exception as e:
            tg_send(chat_id, "ERR: " + str(e))
        return

    tg_send(chat_id, "Команды: /start PIN, /health, /bundle N, /latest")


def agent_call(path, params=None):
    params = params or {}
    params["token"] = AGENT_TOKEN
    qs = urllib.parse.urlencode(params)
    url = "http://127.0.0.1:%d%s?%s" % (AGENT_PORT, path, qs)
    with urllib.request.urlopen(url, timeout=30) as r:
        return r.read().decode()

def main():
    if not BOT_TOKEN:
        log("NO TG_BOT_TOKEN"); return
    offset = 0
    while True:
        try:
            raw = http_get(API_BASE + "/getUpdates", {"timeout":20,"offset":offset,"allowed_updates":"[\"message\"]"}, 25)
            upd = json.loads(raw)
            for u in upd.get("result",[]):
                offset = u["update_id"] + 1
                m = u.get("message")
                if m and "text" in m:
                    try:
                        handle(m)
                    except Exception as e:
                        log("handler error: "+str(e))
        except Exception as e:
            log("poll error: "+str(e))
            time.sleep(3)

if __name__=="__main__":
    main()
