#!/usr/bin/env python3
import os, json, time, urllib.request, urllib.parse, pathlib

BASE = pathlib.Path(__file__).resolve().parents[1]
DATA = BASE / "data" / "tg_bridge"
LOGF = os.getenv("TG_LOG_FILE", str(BASE / "logs" / "tg_bridge.log"))
DATA.mkdir(parents=True, exist_ok=True)
pathlib.Path(LOGF).parent.mkdir(parents=True, exist_ok=True)

BOT_TOKEN   = os.getenv("TG_BOT_TOKEN","")
API_BASE    = f"https://api.telegram.org/bot{BOT_TOKEN}"
AGENT_PORT  = int(os.getenv("TASK_API_PORT","8766"))
AGENT_TOKEN = os.getenv("TASK_API_TOKEN","changeme")

PIN_FILE   = DATA / "pin.txt"
STATE_FILE = DATA / "authorized.json"

def log(msg):
    ts = time.strftime("%Y-%m-%d %H:%M:%S")
    with open(LOGF,"a",encoding="utf-8") as f:
        f.write(f"{ts} {msg}\n")

def http_get(url, params=None, timeout=30):
    if params:
        url += "?" + urllib.parse.urlencode(params)
    with urllib.request.urlopen(url, timeout=timeout) as r:
        return r.read()

def tg_send(chat_id, text):
    body = urllib.parse.urlencode({"chat_id":chat_id,"text":text}).encode()
    req = urllib.request.Request(API_BASE + "/sendMessage", data=body)
    urllib.request.urlopen(req, timeout=30).read()

def tg_send_document(chat_id, file_path):
    boundary = "----tgform" + str(int(time.time()*1000))
    def part(name, content, filename=None, ctype="application/octet-stream"):
        out = []
        out.append(f"--{boundary}".encode())
        hdr = f'Content-Disposition: form-data; name="{name}"'
        if filename:
            hdr += f'; filename="{filename}"'
        out.append(hdr.encode())
        if filename:
            out.append(f"Content-Type: {ctype}".encode())
        out.append(b"")
        out.append(content if isinstance(content,(bytes,bytearray)) else str(content).encode())
        return b"\r\n".join(out)
    with open(file_path, "rb") as f:
        fb = f.read()
    parts = [
        part("chat_id", str(chat_id)),
        part("document", fb, filename=os.path.basename(file_path), ctype="application/zip"),
        b"--" + boundary.encode() + b"--"
    ]
    body = b"\r\n".join(parts)
    req = urllib.request.Request(API_BASE + "/sendDocument", data=body)
    req.add_header("Content-Type", f"multipart/form-data; boundary={boundary}")
    req.add_header("Content-Length", str(len(body)))
    urllib.request.urlopen(req, timeout=120).read()

def load_state():
    try:
        return json.loads(STATE_FILE.read_text(encoding="utf-8"))
    except Exception:
        return {"authorized": []}

def save_state(st):
    STATE_FILE.write_text(json.dumps(st, ensure_ascii=False), encoding="utf-8")

def check_pin(pin):
    try:
        return PIN_FILE.read_text(encoding="utf-8").strip() == pin.strip()
    except Exception:
        return False

def is_auth(chat_id, st):
    return chat_id in st.get("authorized",[])

def agent_health():
    url = f"http://127.0.0.1:{AGENT_PORT}/health?token={urllib.parse.quote(AGENT_TOKEN)}"
    with urllib.request.urlopen(url, timeout=20) as r:
        return r.read().decode()

def agent_call(path, params=None):
    params = params or {}
    params["token"] = AGENT_TOKEN
    qs = urllib.parse.urlencode(params)
    url = f"http://127.0.0.1:{AGENT_PORT}{path}?{qs}"
    with urllib.request.urlopen(url, timeout=30) as r:
        return r.read().decode()

def handle(msg):
    chat_id = msg.get("chat",{}).get("id")
    text = (msg.get("text") or "").strip()
    st = load_state()

    if text.startswith("/start"):
        parts = text.split(maxsplit=1)
        if len(parts)==2 and check_pin(parts[1]):
            if chat_id not in st["authorized"]:
                st["authorized"].append(chat_id)
                save_state(st)
            tg_send(chat_id, "✅ Связь установлена. Команды: /health, /bundle N, /latest")
        else:
            tg_send(chat_id, "Отправь: /start PIN (генерируется на сервере)")
        return

    if not is_auth(chat_id, st):
        tg_send(chat_id, "⛔ Нет доступа. Используй /start PIN")
        return

    if text.startswith("/health"):
        try:
            tg_send(chat_id, "OK: " + agent_health())
        except Exception as e:
            tg_send(chat_id, "ERR: " + str(e))
        return

    if text.startswith("/bundle"):
        n = 1
        parts = text.split()
        if len(parts)>=2 and parts[1].isdigit():
            n = max(1, int(parts[1]))
        try:
            resp = agent_call("/report_pack", {"count": n})
            tg_send(chat_id, "queued: " + resp)
        except Exception as e:
            tg_send(chat_id, "ERR: " + str(e))
        return
    if text.startswith("/latest"):
        try:
            raw = urllib.request.urlopen(f"http://127.0.0.1:{AGENT_PORT}/reports/list.json", timeout=20).read().decode()
            items = json.loads(raw).get("items", [])
            if not items:
                tg_send(chat_id, "reports пусто")
                return
            latest = items[0]["name"]
            url = f"http://127.0.0.1:{AGENT_PORT}/reports/" + urllib.parse.quote(latest)
            path = BASE / "reports" / latest
            sent_file = False
            try:
                if path.exists() and path.stat().st_size < 45_000_000:
                    tg_send_document(chat_id, str(path))
                    sent_file = True
            except Exception as e:
                log(f"send_document fail: {e} -> link fallback")
            # всегда пришлём ссылку дополнительно (удобно переслать/открыть в браузере)
            tg_send(chat_id, url if url else "нет ссылки")
            return
        except Exception as e:
            tg_send(chat_id, "ERR: " + str(e))
            return
            latest = items[0]["name"]
            url = f"http://127.0.0.1:{AGENT_PORT}/reports/" + urllib.parse.quote(latest)
            path = BASE / "reports" / latest
            if path.exists() and path.stat().st_size < 45_000_000:
                try:
                    tg_send_document(chat_id, str(path))
                except Exception as e:
                    log(f"send_document fail: {e} -> link fallback")
                    tg_send(chat_id, url)
            else:
                tg_send(chat_id, url)
        except Exception as e:
            tg_send(chat_id, "ERR: " + str(e))
        return

    tg_send(chat_id, "Команды: /health, /bundle N, /latest")

def main():
    if not BOT_TOKEN:
        log("NO TG_BOT_TOKEN")
        return
    offset = 0
    while True:
        try:
            raw = http_get(API_BASE + "/getUpdates",
                           {"timeout":20,"offset":offset,"allowed_updates":'["message"]'}, 25)
            upd = json.loads(raw.decode() if isinstance(raw, (bytes,bytearray)) else raw)
            for u in upd.get("result",[]):
                offset = u["update_id"] + 1
                m = u.get("message")
                if m and "text" in m:
                    try:
                        handle(m)
                    except Exception as e:
                        log("handler error: " + str(e))
        except Exception as e:
            log("poll error: " + str(e))
            time.sleep(2)

if __name__ == "__main__":
    main()
