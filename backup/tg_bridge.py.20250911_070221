#!/usr/bin/env python3
import os, json, time, urllib.request, urllib.parse, pathlib, threading, mimetypes

# --- Paths & env
BASE = pathlib.Path(__file__).resolve().parents[1]
DATA = BASE / "data" / "tg_bridge"
LOGF = os.getenv("TG_LOG_FILE", str(BASE / "logs" / "tg_bridge.log"))
DATA.mkdir(parents=True, exist_ok=True)
pathlib.Path(LOGF).parent.mkdir(parents=True, exist_ok=True)

BOT_TOKEN   = os.getenv("TG_BOT_TOKEN","")
API_BASE    = f"https://api.telegram.org/bot{BOT_TOKEN}"
AGENT_PORT  = int(os.getenv("TASK_API_PORT","8766"))
AGENT_TOKEN = os.getenv("TASK_API_TOKEN","changeme")

# –ø–æ–¥–ø–∏—Å–∫–∞ (–Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ, –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –≤–∫–ª—é—á–µ–Ω–∞ –Ω–∞ 30 –¥–Ω–µ–π)
SUBS_REQUIRED = os.getenv("SUBS_REQUIRED","1") == "1"
SUBS_DAYS     = int(os.getenv("SUBS_DAYS","30"))

PIN_FILE   = DATA / "pin.txt"
STATE_FILE = DATA / "authorized.json"

# --- Utils
def log(msg: str):
    ts = time.strftime("%Y-%m-%d %H:%M:%S")
    with open(LOGF, "a", encoding="utf-8") as f:
        f.write(f"{ts} {msg}\n")

def _now(): return int(time.time())

def http_get(url: str, params: dict | None = None, timeout: int = 20) -> str:
    if params:
        url = url + ("&" if "?" in url else "?") + urllib.parse.urlencode(params)
    req = urllib.request.Request(url)
    with urllib.request.urlopen(req, timeout=timeout) as r:
        return r.read().decode()

# --- Telegram send
def tg_send(chat_id: int, text: str):
    body = urllib.parse.urlencode({"chat_id": chat_id, "text": text}).encode()
    req = urllib.request.Request(API_BASE + "/sendMessage", data=body)
    urllib.request.urlopen(req, timeout=30).read()

def tg_send_document(chat_id: int, file_path: str):
    boundary = "----tgform" + str(int(time.time()*1000))
    def part(name, content, filename=None, ctype="application/octet-stream"):
        out = []
        out.append(f"--{boundary}".encode())
        hdr = f'Content-Disposition: form-data; name="{name}"'
        if filename:
            hdr += f'; filename="{filename}"'
        out.append(hdr.encode())
        if filename:
            out.append(f"Content-Type: {ctype}".encode())
        out.append(b"")
        out.append(content if isinstance(content,(bytes,bytearray)) else str(content).encode())
        return b"\r\n".join(out)

    with open(file_path, "rb") as f:
        fb = f.read()

    parts = [
        part("chat_id", str(chat_id)),
        part("document", fb, filename=os.path.basename(file_path), ctype="application/zip"),
        b"--" + boundary.encode() + b"--"
    ]
    body = b"\r\n".join(parts)
    req = urllib.request.Request(API_BASE + "/sendDocument", data=body)
    req.add_header("Content-Type", f"multipart/form-data; boundary={boundary}")
    req.add_header("Content-Length", str(len(body)))
    urllib.request.urlopen(req, timeout=120).read()

# --- State
def load_state():
    try:
        return json.loads(STATE_FILE.read_text(encoding="utf-8"))
    except Exception:
        return {"authorized": [], "subs": {}, "last_report_mtime": 0}

def save_state(st):
    STATE_FILE.write_text(json.dumps(st, ensure_ascii=False, indent=2), encoding="utf-8")

def get_until(st, chat_id):
    rec = st.get("subs", {}).get(str(chat_id))
    return int(rec.get("until", 0)) if isinstance(rec, dict) else 0

def set_until(st, chat_id, ts):
    st.setdefault("subs", {})[str(chat_id)] = {"until": int(ts)}
    return st

def is_active(chat_id, st):
    if not SUBS_REQUIRED:
        return True
    return _now() <= get_until(st, chat_id)

# --- Auth helpers
def check_pin(pin: str) -> bool:
    try:
        return pin.strip() == PIN_FILE.read_text(encoding="utf-8").strip()
    except Exception:
        return False

def is_auth(chat_id: int, st) -> bool:
    return chat_id in st.get("authorized", [])

# --- Agent calls
def agent_health() -> str:
    return http_get(f"http://127.0.0.1:{AGENT_PORT}/health", {"token": AGENT_TOKEN}, 10)

def agent_call(path: str, params: dict | None = None) -> str:
    params = params or {}
    params["token"] = AGENT_TOKEN
    return http_get(f"http://127.0.0.1:{AGENT_PORT}{path}", params, 30)

# --- Handler
def handle(msg: dict):
    chat_id = msg.get("chat", {}).get("id")
    text = (msg.get("text") or "").strip()
    st = load_state()

    # /start PIN
    if text.startswith("/start"):
        parts = text.split(maxsplit=1)
        if len(parts) == 2 and check_pin(parts[1]):
            if chat_id not in st.get("authorized", []):
                st.setdefault("authorized", []).append(chat_id)
            until = _now() + SUBS_DAYS * 86400
            st = set_until(st, chat_id, until)
            save_state(st)
            tg_send(chat_id, "‚úÖ –°–≤—è–∑—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞. –ö–æ–º–∞–Ω–¥—ã: /health, /bundle N, /latest, /status")
            tg_send(chat_id, f"üìÖ –î–æ—Å—Ç—É–ø –¥–æ: {time.strftime('%Y-%m-%d', time.localtime(until))}")
        else:
            tg_send(chat_id, "–û—Ç–ø—Ä–∞–≤—å: /start PIN (PIN —Å–º. –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ).")
        return

    # –¥–æ—Å—Ç—É–ø
    if not is_auth(chat_id, st):
        tg_send(chat_id, "‚õî –ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞. –ò—Å–ø–æ–ª—å–∑—É–π /start PIN")
        return
    if not is_active(chat_id, st):
        left = get_until(st, chat_id) - _now()
        if left > 0:
            days = max(1, left // 86400)
            tg_send(chat_id, f"‚è≥ –î–æ—Å—Ç—É–ø –∏—Å—Ç–µ–∫–∞–µ—Ç, –æ—Å—Ç–∞–ª–æ—Å—å ~{days} –¥.")
        else:
            tg_send(chat_id, "‚õî –î–æ—Å—Ç—É–ø –∏—Å—Ç—ë–∫. –û—Ç–ø—Ä–∞–≤—å —Å–Ω–æ–≤–∞: /start PIN")
        return

    # /status
    if text.startswith("/status"):
        until = get_until(st, chat_id)
        if until <= 0:
            tg_send(chat_id, "üîí –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–µ –∞–∫—Ç–∏–≤–Ω–∞.")
        else:
            days = max(0, (until - _now()) // 86400)
            exp = time.strftime("%Y-%m-%d", time.localtime(until))
            tg_send(chat_id, f"üìÖ –î–æ—Å—Ç—É–ø –¥–æ: {exp} (‚âà{days} –¥.)")
        return

    # /health
    if text.startswith("/health"):
        try:
            h = agent_health()
            tg_send(chat_id, "OK: " + h)
        except Exception as e:
            tg_send(chat_id, "ERR: " + str(e))
        return

    # /bundle N
    if text.startswith("/bundle"):
        n = 1
        parts = text.split()
        if len(parts) >= 2 and parts[1].isdigit():
            n = max(1, int(parts[1]))
        try:
            resp = agent_call("/report_pack", {"count": n})
            tg_send(chat_id, "queued: " + resp)
        except Exception as e:
            tg_send(chat_id, "ERR: " + str(e))
        return

    # /latest ‚Äî —Ñ–∞–π–ª (<45–ú–ë) –∏–ª–∏ —Å—Å—ã–ª–∫–∞
    if text.startswith("/latest"):
        try:
            raw = http_get(f"http://127.0.0.1:{AGENT_PORT}/reports/list.json", None, 20)
            items = json.loads(raw).get("items", [])
            if not items:
                tg_send(chat_id, "reports –ø—É—Å—Ç–æ")
                return
            latest = items[0]["name"]
            url = f"http://127.0.0.1:{AGENT_PORT}/reports/" + urllib.parse.quote(latest)
            path = (BASE / "reports" / latest)
            if path.exists() and path.stat().st_size < 45_000_000:
                try:
                    tg_send_document(chat_id, str(path))
                except Exception as e:
                    log(f"send_document fail: {e} -> link fallback")
                    tg_send(chat_id, url)
            else:
                tg_send(chat_id, url)
        except Exception as e:
            tg_send(chat_id, "ERR: " + str(e))
        return

    tg_send(chat_id, "–ö–æ–º–∞–Ω–¥—ã: /health, /bundle N, /latest, /status")

# --- notify loop
def notify_loop():
    st = load_state()
    last = int(st.get("last_report_mtime", 0))
    while True:
        try:
            raw = http_get(f"http://127.0.0.1:{AGENT_PORT}/reports/list.json", None, 10)
            items = json.loads(raw).get("items", [])
            if items:
                m = int(items[0].get("mtime", 0))
                name = items[0].get("name")
                if name and m > last:
                    path = (BASE / "reports" / name)
                    url = f"http://127.0.0.1:{AGENT_PORT}/reports/" + urllib.parse.quote(name)
                    st = load_state()
                    for chat_id in st.get("authorized", []):
                        try:
                            if path.exists() and path.stat().st_size < 45_000_000:
                                try:
                                    tg_send_document(chat_id, str(path))
                                except Exception as e:
                                    log(f"send_document fail: {e} -> link fallback")
                                    tg_send(chat_id, url)
                            else:
                                tg_send(chat_id, url)
                        except Exception as e:
                            log(f"notify send error: {e}")
                    last = m
                    st["last_report_mtime"] = last
                    save_state(st)
            time.sleep(10)
        except Exception as e:
            log(f"notify_loop error: {e}")
            time.sleep(10)

# --- main poll
def main():
    try:
        threading.Thread(target=notify_loop, daemon=True).start()
    except Exception as e:
        log("notify thread start error: " + str(e))

    if not BOT_TOKEN:
        log("NO TG_BOT_TOKEN")
        return

    offset = 0
    while True:
        try:
            raw = http_get(
                API_BASE + "/getUpdates",
                {"timeout": 20, "offset": offset, "allowed_updates": '["message"]'},
                25
            )
            upd = json.loads(raw)
            for u in upd.get("result", []):
                offset = u["update_id"] + 1
                m = u.get("message")
                if m and "text" in m:
                    try:
                        handle(m)
                    except Exception as e:
                        log("handle error: " + str(e))
        except Exception as e:
            log("poll error: " + str(e))
            time.sleep(2)

if __name__ == "__main__":
    main()
