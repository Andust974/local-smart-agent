#!/usr/bin/env python3
import os, base64, json, urllib.parse, http.server, socketserver, time, pathlib

PORT  = int(os.getenv("TASK_API_PORT", "8766"))
TOKEN = os.getenv("TASK_API_TOKEN", "changeme")
USER  = os.getenv("TASK_API_BASIC_USER", "lsa")
PASS  = os.getenv("TASK_API_BASIC_PASS", "changeme")

BASE = pathlib.Path(__file__).resolve().parents[1]
INBOX = BASE / "tasks" / "inbox"
REPORTS = BASE / "reports"
INBOX.mkdir(parents=True, exist_ok=True)
REPORTS.mkdir(parents=True, exist_ok=True)

BASIC_OK = "Basic " + base64.b64encode(f"{USER}:{PASS}".encode()).decode()

def auth_ok(headers, query):
    # 1) Basic Auth
    auth = headers.get("Authorization", "")
    if auth == BASIC_OK:
        return True
    # 2) Fallback: token в query (?token=...)
    token = query.get("token", [None])[0]
    return token is not None and token == TOKEN

class Handler(http.server.BaseHTTPRequestHandler):
    server_version = "TaskAPI/1.1"

    def _json(self, code, obj):
        data = json.dumps(obj, ensure_ascii=False).encode()
        self.send_response(code)
        self.send_header("Content-Type","application/json; charset=utf-8")
        self.send_header("Content-Length", str(len(data)))
        self.end_headers()
        self.wfile.write(data)

    def do_GET(self):
        parsed = urllib.parse.urlparse(self.path)
        qs = urllib.parse.parse_qs(parsed.query)

        if parsed.path == "/health":
            # /health открыт только для авторизованных (Basic или token)
            if not auth_ok(self.headers, qs):
                self.send_response(401)
                self.send_header("WWW-Authenticate","Basic realm=\"TaskAPI\"")
                self.end_headers()
                return
            return self._json(200, {"status":"ok","ts":int(time.time())})

        if parsed.path == "/report_pack":
            # требуется авторизация
            if not auth_ok(self.headers, qs):
                self.send_response(401)
                self.send_header("WWW-Authenticate","Basic realm=\"TaskAPI\"")
                self.end_headers()
                return
            count = 1
            try:
                if "count" in qs:
                    count = max(1, int(qs["count"][0]))
            except Exception:
                count = 1
            task = {
                "kind": "report_pack",
                "count": count,
                "ts": int(time.time())
            }
            ts = time.strftime("%Y%m%d_%H%M%S")
            name = f"task_{ts}_report_pack.json"
            (INBOX / name).write_text(json.dumps(task, ensure_ascii=False), encoding="utf-8")
            return self._json(200, {"queued": f"tasks/inbox/{name}"})

        # 404
        return self._json(404, {"error":"not found"})

    def log_message(self, fmt, *args):
        # тише в логах
        pass

with socketserver.TCPServer(("127.0.0.1", PORT), Handler) as httpd:
    httpd.allow_reuse_address = True
    print(f"# Task-API listening on 127.0.0.1:{PORT}")
    try:
        httpd.serve_forever()
    except KeyboardInterrupt:
        pass
