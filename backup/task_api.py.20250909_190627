#!/usr/bin/env python3
import os, base64, json, urllib.parse, http.server, socketserver, time, pathlib, mimetypes

PORT  = int(os.getenv("TASK_API_PORT", "8766"))
TOKEN = os.getenv("TASK_API_TOKEN", "changeme")
USER  = os.getenv("TASK_API_BASIC_USER", "lsa")
PASS  = os.getenv("TASK_API_BASIC_PASS", "changeme")

BASE = pathlib.Path(__file__).resolve().parents[1]
INBOX = BASE / "tasks" / "inbox"
REPORTS = BASE / "reports"
SANDBOX = BASE / "sandbox"
INBOX.mkdir(parents=True, exist_ok=True)
REPORTS.mkdir(parents=True, exist_ok=True)
SANDBOX.mkdir(parents=True, exist_ok=True)

BASIC_OK = "Basic " + base64.b64encode(f"{USER}:{PASS}".encode()).decode()

def auth_ok(headers, query):
    # 1) Basic
    auth = headers.get("Authorization", "")
    if auth == BASIC_OK:
        return True
    # 2) token fallback
    token = query.get("token", [None])[0]
    return token is not None and token == TOKEN

class Handler(http.server.BaseHTTPRequestHandler):
    server_version = "TaskAPI/1.2"

    # ===== helpers =====
    def _set_cors(self):
        self.send_header("Access-Control-Allow-Origin", "*")
        self.send_header("Access-Control-Allow-Methods", "GET,OPTIONS")
        self.send_header("Access-Control-Allow-Headers", "Authorization,Content-Type")

    def _json(self, code, obj):
        data = json.dumps(obj, ensure_ascii=False).encode()
        self.send_response(code)
        self._set_cors()
        self.send_header("Content-Type","application/json; charset=utf-8")
        self.send_header("Content-Length", str(len(data)))
        self.end_headers()
        self.wfile.write(data)

    def _unauth(self):
        self.send_response(401)
        self._set_cors()
        self.send_header("WWW-Authenticate","Basic realm=\"TaskAPI\"")
        self.end_headers()

    def do_OPTIONS(self):
        self.send_response(204)
        self._set_cors()
        self.end_headers()

    # ===== routes =====
    def do_GET(self):
        parsed = urllib.parse.urlparse(self.path)
        qs = urllib.parse.parse_qs(parsed.query)

        # static: / or /dashboard.html (без авторизации)
        if parsed.path in ("/", "/dashboard.html"):
            p = SANDBOX / "dashboard.html"
            if p.exists():
                data = p.read_bytes()
                self.send_response(200)
                self._set_cors()
                ctype = mimetypes.guess_type(str(p))[0] or "text/html; charset=utf-8"
                self.send_header("Content-Type", ctype)
                self.send_header("Content-Length", str(len(data)))
                self.end_headers()
                self.wfile.write(data)
            else:
                self._json(404, {"error":"dashboard.html not found"})
            return

        if parsed.path == "/health":
            if not auth_ok(self.headers, qs):
                return self._unauth()
            return self._json(200, {"status":"ok","ts":int(time.time())})

        if parsed.path == "/report_pack":
            if not auth_ok(self.headers, qs):
                return self._unauth()
            count = 1
            try:
                if "count" in qs:
                    count = max(1, int(qs["count"][0]))
            except Exception:
                count = 1
            task = {"kind":"report_pack","count":count,"ts":int(time.time())}
            ts = time.strftime("%Y%m%d_%H%M%S")
            name = f"task_{ts}_report_pack.json"
            (INBOX / name).write_text(json.dumps(task, ensure_ascii=False), encoding="utf-8")
            return self._json(200, {"queued": f"tasks/inbox/{name}"})

        return self._json(404, {"error":"not found"})

    def log_message(self, fmt, *args):
        # тише в логах
        pass

with socketserver.TCPServer(("127.0.0.1", PORT), Handler) as httpd:
    httpd.allow_reuse_address = True
    print(f"# Task-API listening on 127.0.0.1:{PORT}")
    try:
        httpd.serve_forever()
    except KeyboardInterrupt:
        pass
