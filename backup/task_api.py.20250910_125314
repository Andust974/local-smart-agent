#!/usr/bin/env python3
import os, base64, json, urllib.parse, http.server, socketserver, time, pathlib, mimetypes

PORT  = int(os.getenv("TASK_API_PORT", "8766"))
TOKEN = os.getenv("TASK_API_TOKEN", "changeme")
USER  = os.getenv("TASK_API_BASIC_USER", "lsa")
PASS  = os.getenv("TASK_API_BASIC_PASS", "changeme")

BASE = pathlib.Path(__file__).resolve().parents[1]
INBOX = BASE / "tasks" / "inbox"
REPORTS = BASE / "reports"
SANDBOX = BASE / "sandbox"
INBOX.mkdir(parents=True, exist_ok=True)
REPORTS.mkdir(parents=True, exist_ok=True)
SANDBOX.mkdir(parents=True, exist_ok=True)

BASIC_OK = "Basic " + base64.b64encode(f"{USER}:{PASS}".encode()).decode()

def auth_ok(headers, query):
    # 1) Basic
    auth = headers.get("Authorization", "")
    if auth == BASIC_OK:
        return True
    # 2) token fallback
    token = query.get("token", [None])[0]
    return token is not None and token == TOKEN

def list_reports(limit=None):
    files = []
    for p in REPORTS.glob("*"):
        if p.is_file():
            try:
                st = p.stat()
            except Exception:
                continue
            files.append({
                "name": p.name,
                "size": st.st_size,
                "mtime": int(st.st_mtime),
                "href": f"/reports/{urllib.parse.quote(p.name)}",
            })
    files.sort(key=lambda x: x["mtime"], reverse=True)
    return files[:limit] if limit else files

class Handler(http.server.BaseHTTPRequestHandler):
    server_version = "TaskAPI/1.3"

    # ===== helpers =====
    def _set_cors(self):
        self.send_header("Access-Control-Allow-Origin", "*")
        self.send_header("Access-Control-Allow-Methods", "GET,OPTIONS")
        self.send_header("Access-Control-Allow-Headers", "Authorization,Content-Type")

    def _json(self, code, obj):
        data = json.dumps(obj, ensure_ascii=False).encode()
        self.send_response(code)
        self._set_cors()
        self.send_header("Content-Type","application/json; charset=utf-8")
        self.send_header("Content-Length", str(len(data)))
        self.end_headers()
        self.wfile.write(data)

    def _html(self, code, html):
        data = html.encode("utf-8")
        self.send_response(code)
        self._set_cors()
        self.send_header("Content-Type","text/html; charset=utf-8")
        self.send_header("Content-Length", str(len(data)))
        self.end_headers()
        self.wfile.write(data)

    def _unauth(self):
        self.send_response(401)
        self._set_cors()
        self.send_header("WWW-Authenticate","Basic realm=\"TaskAPI\"")
        self.end_headers()

    def _send_file(self, path: pathlib.Path):
        # Безопасность: только внутри REPORTS
        try:
            p = path.resolve()
            if REPORTS not in p.parents and p != REPORTS:
                return self._json(403, {"error":"forbidden"})
            if not p.exists() or not p.is_file():
                return self._json(404, {"error":"not found"})
            data = p.read_bytes()
            ctype = mimetypes.guess_type(p.name)[0] or "application/octet-stream"
            self.send_response(200)
            self._set_cors()
            self.send_header("Content-Type", ctype)
            self.send_header("Content-Length", str(len(data)))
            self.send_header("Content-Disposition", f'inline; filename="{p.name}"')
            self.end_headers()
            self.wfile.write(data)
        except Exception as e:
            self._json(500, {"error":"io", "detail": str(e)})

    def do_OPTIONS(self):
        self.send_response(204)
        self._set_cors()
        self.end_headers()

    # ===== routes =====
    def do_GET(self):
        parsed = urllib.parse.urlparse(self.path)
        qs = urllib.parse.parse_qs(parsed.query)
        path = parsed.path

        # static dashboard (без авторизации)
        if path in ("/", "/dashboard.html"):
            p = SANDBOX / "dashboard.html"
            if p.exists():
                data = p.read_bytes()
                self.send_response(200)
                self._set_cors()
                ctype = mimetypes.guess_type(str(p))[0] or "text/html; charset=utf-8"
                self.send_header("Content-Type", ctype)
                self.send_header("Content-Length", str(len(data)))
                self.end_headers()
                self.wfile.write(data)
            else:
                self._json(404, {"error":"dashboard.html not found"})
            return

        # health (авторизован)
        if path == "/health":
            if not auth_ok(self.headers, qs):
                return self._unauth()
            return self._json(200, {"status":"ok","ts":int(time.time())})

        # постановка задач (авторизован)
        if path == "/report_pack":
            if not auth_ok(self.headers, qs):
                return self._unauth()
            count = 1
            try:
                if "count" in qs:
                    count = max(1, int(qs["count"][0]))
            except Exception:
                count = 1
            task = {"kind":"report_pack","count":count,"ts":int(time.time())}
            ts = time.strftime("%Y%m%d_%H%M%S")
            name = f"task_{ts}_report_pack.json"
            (INBOX / name).write_text(json.dumps(task, ensure_ascii=False), encoding="utf-8")
            return self._json(200, {"queued": f"tasks/inbox/{name}"})

        # ===== reports: открытый просмотр (без авторизации, локальный) =====
        if path == "/reports/list.json":
            return self._json(200, {"items": list_reports()})

        if path == "/reports/latest":
            items = list_reports(limit=1)
            if not items:
                return self._json(404, {"error":"empty"})
            latest = items[0]["name"]
            self.send_response(302)
            self._set_cors()
            self.send_header("Location", f"/reports/{urllib.parse.quote(latest)}")
            self.end_headers()
            return

        if path == "/reports" or path == "/reports/":
            items = list_reports()
            rows = "\n".join(
                f'<li><a href="/reports/{urllib.parse.quote(i["name"])}">{i["name"]}</a> '
                f'— {i["size"]} bytes — {time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(i["mtime"]))}</li>'
                for i in items
            ) or "<li><em>папка пуста</em></li>"
            html = f"""<!doctype html><meta charset="utf-8">
            <title>Reports</title>
            <h1>Reports</h1>
            <p><a href="/dashboard.html">← Dashboard</a></p>
            <ul>{rows}</ul>"""
            return self._html(200, html)

        # download отдельного файла из reports
        if path.startswith("/reports/"):
            fname = urllib.parse.unquote(path.split("/reports/",1)[1])
            return self._send_file(REPORTS / fname)

        # default 404
        return self._json(404, {"error":"not found"})

    def log_message(self, fmt, *args):
        pass

with socketserver.TCPServer(("127.0.0.1", PORT), Handler) as httpd:
    httpd.allow_reuse_address = True
    print(f"# Task-API listening on 127.0.0.1:{PORT}")
    try:
        httpd.serve_forever()
    except KeyboardInterrupt:
        pass
